#!/bin/bash
# scan-button-poll - Poll ScanSnap ix500 button and trigger scan
# Designed to be started/stopped by udev on USB connect/disconnect

POLL_INTERVAL=0.1
DEBOUNCE=3

# Resolve scan script relative to this script's location
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
SCAN_SCRIPT="$SCRIPT_DIR/scan"

log() {
    echo "[$(date '+%H:%M:%S')] $1"
}

# Auto-detect scanner device: try USB (fujitsu) first, then WiFi (eSCL)
detect_device() {
    local dev
    dev=$(scanimage -L 2>/dev/null | grep -oP "fujitsu:ScanSnap iX500:\d+" | head -1)
    [ -z "$dev" ] && dev=$(scanimage -L 2>/dev/null | grep -oP "escl:[^ '\"]*" | head -1)
    echo "$dev"
}

get_button_state() {
    # Read scanner options, extract scan button state
    scanimage --device "$DEVICE" -A 2>/dev/null | grep -oP '(?<=--scan\[=\(yes\|no\)\] \[)\w+' || echo "error"
}

# Scanner device — from env or auto-detect
if [ -n "$SCANNER_DEVICE" ]; then
    DEVICE="$SCANNER_DEVICE"
else
    DEVICE=$(detect_device)
fi
if [ -z "$DEVICE" ]; then
    log "Error: ScanSnap iX500 not found"
    exit 1
fi

# Determine backend from device string
case "$DEVICE" in
    fujitsu:*) BACKEND=fujitsu ;;
    escl:*)    BACKEND=escl ;;
    *)         BACKEND=fujitsu ;;
esac

log "Starting button poll for $DEVICE ($BACKEND backend)"

# WiFi (eSCL) button polling is not yet supported — the iX500 uses a proprietary
# TCP notification on port 55265 that hasn't been reverse-engineered yet.
# Keep the service alive so it doesn't restart-thrash.
if [ "$BACKEND" = "escl" ]; then
    log "WiFi button polling not yet supported (see: just listen)"
    log "Idle — waiting for future protocol implementation"
    while true; do
        sleep 60
    done
fi

# Wait for scanner to be ready
sleep 2

# Main polling loop
while true; do
    button_state=$(get_button_state)

    if [ "$button_state" = "yes" ]; then
        log "Button pressed! Starting scan..."

        # Run the scan script, capture output
        SCAN_OUTPUT=$("$SCAN_SCRIPT" 2>&1) && SCAN_OK=true || SCAN_OK=false
        echo "$SCAN_OUTPUT"

        if [ "$SCAN_OK" = true ]; then
            log "Scan completed successfully"
            # Send clickable desktop notification (in background to not block polling)
            if [ -n "$PAPERLESS_URL" ]; then
                (
                    ACTION=$(notify-send -i scanner --action="open=Open in Paperless" \
                        "Scan Complete" "Document uploaded to Paperless" 2>/dev/null)
                    [ "$ACTION" = "open" ] && xdg-open "$PAPERLESS_URL" 2>/dev/null
                ) &
            elif [ -n "$PAPERLESS_CONSUME_DIR" ]; then
                OUTFILE=$(echo "$SCAN_OUTPUT" | grep -oP '(?<=Done: )\S+')
                (
                    ACTION=$(notify-send -i scanner --action="open=Open" \
                        "Scan Complete" "Document saved to consume folder" 2>/dev/null)
                    [ "$ACTION" = "open" ] && xdg-open "$OUTFILE" 2>/dev/null
                ) &
            else
                OUTFILE=$(echo "$SCAN_OUTPUT" | grep -oP '(?<=Done: )\S+')
                (
                    ACTION=$(notify-send -i scanner --action="open=Open" \
                        "Scan Complete" "Document saved to scanner-inbox" 2>/dev/null)
                    [ "$ACTION" = "open" ] && xdg-open "$OUTFILE" 2>/dev/null
                ) &
            fi
        else
            log "Scan failed"
            (
                ACTION=$(notify-send -u critical -i dialog-error --action="logs=View Logs" \
                    "Scan Failed" "Something went wrong during scanning" 2>/dev/null)
                [ "$ACTION" = "logs" ] && xdg-terminal-exec journalctl --user -u scan-button.service -n 50 --no-pager 2>/dev/null
            ) &
        fi

        # Debounce - wait before polling again to let button release
        log "Waiting for button release..."
        sleep "$DEBOUNCE"

    elif [ "$button_state" = "error" ]; then
        log "Scanner not responding, waiting..."
        sleep 5
    fi

    sleep "$POLL_INTERVAL"
done
